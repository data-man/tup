diff ./lauxlib.c ../patched/lauxlib.c
--- ./lauxlib.c	2020-11-13 20:32:00.000000000 +0500
+++ ../patched/lauxlib.c	2021-02-22 03:29:30.080115301 +0500
@@ -1061,6 +1061,10 @@
   warnfcont(ud, message, tocont);  /* finish processing */
 }
 
+LUALIB_API void luaL_setoutput (lua_State *L, FILE *output) {
+  lua_setoutput(L, output);
+}
+
 
 LUALIB_API lua_State *luaL_newstate (void) {
   lua_State *L = lua_newstate(l_alloc, NULL);
diff ./lauxlib.h ../patched/lauxlib.h
--- ./lauxlib.h	2020-11-13 20:32:00.000000000 +0500
+++ ../patched/lauxlib.h	2021-02-22 03:29:07.173115878 +0500
@@ -99,6 +99,8 @@
 
 LUALIB_API lua_State *(luaL_newstate) (void);
 
+LUALIB_API void (luaL_setoutput) (lua_State *L, FILE *output);
+
 LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);
 
 LUALIB_API void luaL_addgsub (luaL_Buffer *b, const char *s,
@@ -246,6 +248,9 @@
         (fprintf(stderr, (s), (p)), fflush(stderr))
 #endif
 
+#define lua_writestringout(s,l,ls)  fwrite((s), sizeof(char), (l), ls->output)
+#define lua_writelineout(ls)  (lua_writestringout("\n", 1, ls), fflush(ls->output))
+
 /* }================================================================== */
 
 
diff ./lbaselib.c ../patched/lbaselib.c
--- ./lbaselib.c	2020-11-13 20:32:00.000000000 +0500
+++ ../patched/lbaselib.c	2021-02-22 03:23:00.373125122 +0500
@@ -19,7 +19,7 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
+#include "lstate.h"
 
 static int luaB_print (lua_State *L) {
   int n = lua_gettop(L);  /* number of arguments */
@@ -27,12 +27,11 @@
   for (i = 1; i <= n; i++) {  /* for each argument */
     size_t l;
     const char *s = luaL_tolstring(L, i, &l);  /* convert it to string */
-    if (i > 1)  /* not the first element? */
-      lua_writestring("\t", 1);  /* add a tab before it */
-    lua_writestring(s, l);  /* print it */
+    if (i>1) lua_writestringout("\t", 1, L);
+    lua_writestringout(s, l, L);    
     lua_pop(L, 1);  /* pop result */
   }
-  lua_writeline();
+  lua_writelineout(L);
   return 0;
 }
 
diff ./llex.c ../patched/llex.c
--- ./llex.c	2020-11-13 20:32:01.000000000 +0500
+++ ../patched/llex.c	2021-02-22 03:25:47.009120923 +0500
@@ -44,7 +44,8 @@
     "return", "then", "true", "until", "while",
     "//", "..", "...", "==", ">=", "<=", "~=",
     "<<", ">>", "::", "<eof>",
-    "<number>", "<integer>", "<name>", "<string>"
+    "<number>", "<integer>", "<name>", "<string>",
+    "!="
 };
 
 
@@ -507,6 +508,11 @@
         if (check_next1(ls, '=')) return TK_NE;  /* '~=' */
         else return '~';
       }
+      case '!': {
+        next(ls);
+        if (ls->current != '=') return '!';
+        else { next(ls); return TK_NE2; }
+      }
       case ':': {
         next(ls);
         if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */
diff ./llex.h ../patched/llex.h
--- ./llex.h	2020-11-13 20:32:01.000000000 +0500
+++ ../patched/llex.h	2021-02-22 03:25:23.925121504 +0500
@@ -39,7 +39,8 @@
   TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
   TK_SHL, TK_SHR,
   TK_DBCOLON, TK_EOS,
-  TK_FLT, TK_INT, TK_NAME, TK_STRING
+  TK_FLT, TK_INT, TK_NAME, TK_STRING,
+  TK_NE2
 };
 
 /* number of reserved words */
diff ./lparser.c ../patched/lparser.c
--- ./lparser.c	2020-11-13 20:32:01.000000000 +0500
+++ ../patched/lparser.c	2021-02-22 03:26:48.697119368 +0500
@@ -1207,6 +1207,7 @@
     case TK_SHR: return OPR_SHR;
     case TK_CONCAT: return OPR_CONCAT;
     case TK_NE: return OPR_NE;
+    case TK_NE2: return OPR_NE;
     case TK_EQ: return OPR_EQ;
     case '<': return OPR_LT;
     case TK_LE: return OPR_LE;
@@ -1353,6 +1354,80 @@
   }
 }
 
+#define BITRK               (1 << (SIZE_B - 1))
+#define ISK(x)              ((x) & BITRK)
+
+static void append_assignment (LexState *ls, struct LHS_assign *lh) {
+  FuncState * fs=ls->fs;
+  TString *appendfunc_name;
+  expdesc appendfunc;
+  expdesc var;
+  expdesc value;
+  int base;
+
+  luaX_next(ls);
+
+  checknext(ls, '=');
+
+  /* Push tup_append_assignment onto the stack */
+  /* Note: copied from function call suffixedexp -> primaryexp -> singlevar */
+  appendfunc_name = luaS_new(ls->L, "tup_append_assignment");
+  singlevaraux(fs, appendfunc_name, &appendfunc, 1);
+  if (appendfunc.k == VVOID) {
+    /* If tup_append_assignment isn't global, then check _ENV/locals
+     * Note: reuse appendfunc to reference _ENV temporarily
+     */
+    expdesc key;
+    /* Locate _ENV and make it an upvalue if necessary */
+    singlevaraux(fs, ls->envn, &appendfunc, 1);
+    lua_assert(appendfunc.k == VLOCAL || appendfunc.k == VUPVAL);
+    codename(ls, &key);
+    codestring(&key, appendfunc_name);
+    luaK_indexed(fs, &appendfunc, &key);  /* env[varname] */
+  }
+  luaK_exp2nextreg(fs, &appendfunc);
+
+  /* Push assignment lhs as first function argument */
+  var = lh->v; /* exp2nextreg disables the expr somehow, so copy it first */
+  if (var.k == VINDEXED) {
+    /* exp2nextreg if INDEXED will try to pop/reuse the source table and
+     * index stack positions.
+     * Increase freeregs to prevent that.
+     * The conditions need to match those in and around freereg in
+     * luaK_dischargevars exactly.
+     */
+    if (!ISK(var.u.ind.idx) && var.u.ind.idx >= fs->nactvar) {
+      fs->freereg += 1;
+    }
+    if (var.u.ind.t == VLOCAL) {
+      if (!ISK(var.u.ind.t) && var.u.ind.t >= fs->nactvar) {
+        fs->freereg += 1;
+      }
+    }
+  }
+  luaK_exp2nextreg(fs, &var);
+
+  /* Push original rhs as second function argument */
+  expr(ls, &value);
+  luaK_exp2nextreg(fs, &value);
+
+  /* Call the function */
+  /* Note: copied from funcargs */
+  lua_assert(appendfunc.k == VNONRELOC);
+  base = appendfunc.u.info;  /* base register for call */
+  init_exp(&appendfunc, VCALL,
+      luaK_codeABC(fs, OP_CALL, base, fs->freereg - (base + 1) + 1, 2));
+  fs->freereg = base + 1;  /* call removes function and arguments and leaves
+                          (unless changed) one result */
+
+  /* Store the call result */
+  luaK_storevar(fs, &lh->v, &appendfunc);
+}
+
+#undef BITRK
+#undef ISK
+
+
 /*
 ** Parse and compile a multiple assignment. The first "variable"
 ** (a 'suffixedexp') was already read by the caller.
@@ -1376,6 +1451,12 @@
   }
   else {  /* restassign -> '=' explist */
     int nexps;
+    if(nvars==1) {
+      if(ls->t.token == '+') {
+        append_assignment(ls, lh);
+        return;
+      }
+    }
     checknext(ls, '=');
     nexps = explist(ls, &e);
     if (nexps != nvars)
@@ -1786,7 +1867,7 @@
   FuncState *fs = ls->fs;
   struct LHS_assign v;
   suffixedexp(ls, &v.v);
-  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
+  if (ls->t.token == '=' || ls->t.token == ',' || ls->t.token == '+') { /* stat -> assignment ? */
     v.prev = NULL;
     restassign(ls, &v, 1);
   }
diff ./lstate.c ../patched/lstate.c
--- ./lstate.c	2020-11-13 20:32:01.000000000 +0500
+++ ../patched/lstate.c	2021-02-22 03:23:53.253123789 +0500
@@ -398,10 +398,16 @@
     close_state(L);
     L = NULL;
   }
+  L->output = stdout;
   return L;
 }
 
 
+LUA_API void lua_setoutput (lua_State *L, FILE *output) {
+  L->output = output;
+}
+
+
 LUA_API void lua_close (lua_State *L) {
   lua_lock(L);
   L = G(L)->mainthread;  /* only the main thread can be closed */
diff ./lstate.h ../patched/lstate.h
--- ./lstate.h	2020-11-13 20:32:01.000000000 +0500
+++ ../patched/lstate.h	2021-02-22 03:24:16.621123200 +0500
@@ -12,6 +12,7 @@
 #include "lobject.h"
 #include "ltm.h"
 #include "lzio.h"
+#include <stdio.h>
 
 
 /*
@@ -274,6 +275,7 @@
   CommonHeader;
   lu_byte status;
   lu_byte allowhook;
+  FILE *output;
   unsigned short nci;  /* number of items in 'ci' list */
   StkId top;  /* first free slot in the stack */
   global_State *l_G;
diff ./lua.h ../patched/lua.h
--- ./lua.h	2020-11-13 20:32:02.000000000 +0500
+++ ../patched/lua.h	2021-02-22 03:27:37.658118134 +0500
@@ -9,6 +9,7 @@
 #ifndef lua_h
 #define lua_h
 
+#include <stdio.h>
 #include <stdarg.h>
 #include <stddef.h>
 
@@ -152,6 +153,7 @@
 */
 LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
 LUA_API void       (lua_close) (lua_State *L);
+LUA_API void       (lua_setoutput) (lua_State *L, FILE *output);
 LUA_API lua_State *(lua_newthread) (lua_State *L);
 LUA_API int        (lua_resetthread) (lua_State *L);
 
